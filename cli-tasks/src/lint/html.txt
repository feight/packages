

import path from "path";

import { CLIEngine } from "eslint";
import vinyl from "vinyl";
import {
    watch,
    WatchOptions
} from "@newsteam/cli-utils";
import {
    LintError,
    LintErrorData
} from "@newsteam/cli-errors";
import { logger } from "@newsteam/cli-logger";


export class HtmlLintError extends LintError{

    constructor(data: LintErrorData[]){

        super(data);

        this.name = "HtmlLintError";

        this.description = "HtmlLint Error";

    }

}

export interface HtmlLintFile extends vinyl{
    eslint: {
        fixed: boolean;
    };
}


export interface EslintTaskConfig{
    cache: boolean;
    fix: boolean;
}


export interface EslintLintTaskOptions extends WatchOptions{
    config?: EslintTaskConfig;
    destination: string;
    source: string;
    label?: string;
}


export const eslintLintTask = async function(options: EslintLintTaskOptions): Promise<void>{

    const label = options.label ?? "lint";

    const config: EslintTaskConfig = {
        cache: true,
        fix: false,
        ...options.config
    };

    const eslintCLI = new CLIEngine({
        cache: config.cache,
        cacheLocation: ".local/cache/@newsteam/cli-tasks/.eslintcache",
        fix: config.fix,
        useEslintrc: true
    });

    await watch(options, async (files: string[]): Promise<void> => {

        await new Promise((resolve) => {

            const config_ = merge.recursive({ failOnError: !watching }, this.config.htmllint);
            const callback = (filepath, issues) => {

                if(issues.length > 0){

                    const errorOutput = issues.map((issue) => {

                        const errorFrame = codeframe.get({
                            column: issue.column,
                            file: filepath,
                            line: issue.line
                        });

                        return `${ filepath }:${ issue.line }\n${ issue.msg }\n\n${ errorFrame }\n`;

                    }).join("\n");

                    log(`${ chalk.red("HTML Lint Error ") }:\n${ errorOutput }`);

                    process.exitCode = 1;

                    process.stdout.write("\u0007");

                }

            };

            return this.src(paths)
            .pipe(print((p) => `Lint: ${ p }`))
            .pipe(watching ? htmllint(config_, callback) : cache(htmllint(config_, callback)));


            const error = new HtmlLintError(errors);

            if(options.watch){

                logger.error(error);

            }else if(errors.length > 0){

                throw error;

            }

            resolve();

        });

    });

};

